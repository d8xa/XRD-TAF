// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel g1_dists
#pragma kernel g2_dists
#pragma kernel Absorptions2D
#pragma kernel Absorptions3D
//#pragma fragment frag
//#pragma fragmentoption ARB_precision_hint_nicest


float r_cell;       // outer radius
float r_sample;     // inner radius
float r_cell_sq;    // outer radius squared
float r_sample_sq;  // inner radius squared

float cos;          // cos(180-2*theta)
float sin;          // sin(180-2*theta)
float2 mu;          // absorption factors in cell, sample.
float bufCount_Segments;    // number of segment coordinates.
float bufCount_Factors;   // number of absorption factors in 2D case.
uint bufIndex_Factors;   // index where to write absorption factor into.

//uint cos_alpha_count;    // nr of stretch factors.

/* CONTENT: Read-only buffers. */
StructuredBuffer<float2> segment;                   // list of segment coordinates.
StructuredBuffer<float3> cos_alpha_list;            // list of ratios of extended DR distance in 2D to 3D.

/* CONTENT: 
 *  mode=Point: g1_dists from script, precomputed in shader.
 *  mode=Area: g1_dists from script, g2_dists from shader for each theta.
 */
RWStructuredBuffer<float2> distancesOuter;          // Diffraction only in cell.
RWStructuredBuffer<float2> distancesInner;          // Diffraction only in sample.

/* Absorption */
RWStructuredBuffer<float3> absorptions2D;           // Pointwise absorption factors.
RWStructuredBuffer<float3> absorptionFactors2D;     // Absorption factors with diffraction/absorption in (s,sc), (c,sc), (c,c).
//RWStructuredBuffer<float3> absorptions3D;          // Absorption values with diffraction/absorption in (s,sc), (c,sc), (c,c).
//RWStructuredBuffer<float> cos_alphas;          


// TODO: test efficiency of radius*radius vs radius_sq.

float getIntersectX (float2 v, float radius_sq, bool right)
{
    if (right)
    { 
        return sqrt(abs(radius_sq - pow(v.y, 2)));
    } 
    return -sqrt(abs(radius_sq - pow(v.y, 2)));
}

float2 ER_dists_F1 (float2 v)
{
    float d_cell = 0.0;
    float d_sample = 0.0;
    
    if (length(v) <= r_sample)
    {
        d_cell = abs(getIntersectX(v, r_sample_sq, false) - getIntersectX(v, r_cell_sq, false));
        d_sample = abs(v.x - getIntersectX(v, r_sample_sq, false));
    }
    return float2(d_cell, d_sample);
}

float2 ER_dists_F2 (float2 v)
{
    float d_cell = 0.0;
    float d_sample = 0.0;
    if (length(v) > r_sample & length(v) <= r_cell)
    {
        float RENx_o = getIntersectX(v, r_cell_sq, false);
        if (v.x >= 0 & abs(v.y) < r_sample)
        {
            float RENx_i = getIntersectX(v, r_sample_sq, false);
            float REXx_i = getIntersectX(v, r_sample_sq, true);
            d_cell = abs(RENx_o - RENx_i) + abs(REXx_i - v.x);
            d_sample = abs(RENx_i - REXx_i);
        }
        else
        {
            d_cell = abs(RENx_o - v.x);
        }
    }
    return float2(d_cell, d_sample);
}

/* call ER_dists for coordinate per diffraction case, save in shader variable. */
[numthreads(1024,1,1)]
void g1_dists (uint3 id : SV_DispatchThreadID)
{
    distancesOuter[id.x] = ER_dists_F2(segment[id.x]); 
    distancesInner[id.x] = ER_dists_F1(segment[id.x]);
}

/* call ER_dists for rotated coordinate per diffraction case, add to shader variable. */
[numthreads(1024,1,1)]
void g2_dists (uint3 id : SV_DispatchThreadID)
{
    float2 rv = float2(
        cos*segment[id.x].x-sin*segment[id.x].y, 
        sin*segment[id.x].x+cos*segment[id.x].y
    );
    distancesOuter[id.x] = distancesOuter[id.x] + ER_dists_F2(rv);
    distancesInner[id.x] = distancesInner[id.x] + ER_dists_F1(rv);
}

[numthreads(1024,1,1)]
void Absorptions2D(uint3 id : SV_DispatchThreadID){
    float2 rv = float2(
        cos*segment[id.x].x-sin*segment[id.x].y, 
        sin*segment[id.x].x+cos*segment[id.x].y
    );
    float norm = length(segment[id.x]);
    
    if (norm <= r_cell)
    {
        if (norm > r_sample)
        {
            float d_outer = distancesOuter[id.x] + ER_dists_F2(rv);
            absorptions2D[id.x].y = exp(-dot(mu, d_outer));                 // case A_{c,sc}.
            absorptions2D[id.x].z = exp(-dot(float2(mu.x, 0.0), d_outer));  // case A_{c,c}.
        }
        else 
        {
            absorptions2D[id.x].x = exp(-dot(mu, distancesInner[id.x] + ER_dists_F1(rv)));                 // case A_{s,sc}.
        }
    } 
}

/**
* @param index: the index of each theta.
*/
//[numthreads(1024,1,1)]
void absorptionFactor2D()
{
    // TODO: check float accuracy.
    float3 absorptionSum = float3(0.0, 0.0, 0.0);
    uint3 diffractionPointCounts = uint3(0, 0, 0);
    
    for (uint i = 0; i < bufCount_Segments; i++)
    {
        float norm = length(segment[i]);
        if (norm <= r_cell)
        {
            if (norm > r_sample)
            {
                absorptionSum.y = absorptionSum.y + Absorptions2D[i].y;
                absorptionSum.z = absorptionSum.z + Absorptions2D[i].z;
            }
            else
            {
                absorptionSum.x = absorptionSum.x + Absorptions2D[i].x;
            }
        }
    }
    
    for (uint i = 0; i < 3; i++) {
        if (diffractionPointCounts[i] == 0)
            diffractionPointCounts[i] = 1;
    }
    absorptionFactor2D[bufIndex_Factors] = absorptionSum/diffractionPointCounts;
}


[numthreads(1024,1,1)]
void absorptionFactor3D(uint3 id : SV_DispatchThreadID)
{
    // TODO: check float accuracy.
    // distances
    // stretch
    // absorptions
    float3 absorptionSum = float3(0.0, 0.0, 0.0);
    uint3 diffractionPointCounts = uint3(0, 0, 0);
    
    for (uint i = 0; i < bufCount_Segments; i++)
    {
        float norm = length(segment[i]);
        if (norm <= r_cell)
        {
            if (norm > r_sample)
            {
                absorptionSum.y = absorptionSum.y + absorption()
                    + Absorptions2D[i].y;
                absorptionSum.z = absorptionSum.z 
                    + Absorptions2D[i].z;
            }
            else
            {
                absorptionSum.x = absorptionSum.x + Absorptions2D[i].x;
            }
        }
    }
    
    for (uint i = 0; i < 3; i++) {
        if (diffractionPointCounts[i] == 0)
            diffractionPointCounts[i] = 1;
    }
    absorptionFactor3D[id.x] = absorptionSum/diffractionPointCounts;
}