// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel g1_dists
#pragma kernel g2_dists
#pragma kernel identity


float r_cell;       // outer radius
float r_sample;     // inner radius
float r_cell_sq;    // outer radius squared
float r_sample_sq;  // inner radius squared
//float2x2 rot_mat;   // 2D rotation matrix by angle defined in script.


StructuredBuffer<float2> segment;

/* INPUT: g1_dists from script, precomputed in shader. (maybe keep in shader) */
RWStructuredBuffer<float2> distancesOuter;       // Diffraction only in cell.
RWStructuredBuffer<float2> distancesInner;       // Diffraction only in sample.


// TODO: test efficiency of radius*radius vs radius_sq.

[numthreads(64,1,1)]
void identity(uint3 id : SV_DispatchThreadID)
{
    distancesOuter[id.x] = segment[id.x];
    distancesInner[id.x] = segment[id.x];
}

float norm(float2 v)
{
    return sqrt(v[0]*v[0] + v[1]*v[1]);
}

float getIntersectX (float2 v, float radius_sq, bool right)
{
    if (right)
    { 
        return sqrt(radius_sq - v[1]*v[1]);
    } 
    return -sqrt(radius_sq - v[1]*v[1]);
}

float2 ER_dists_F1 (float2 v)
{
    float d_cell = 0.0;
    float d_sample = 0.0;
    
    if (norm(v) <= r_sample)
    {
        d_cell = abs(getIntersectX(v, r_sample, false) - getIntersectX(v, r_cell, false));
        d_sample = abs(v.x - getIntersectX(v, r_sample, false));
    }
    return float2(d_cell, d_sample);
}

float2 ER_dists_F2 (float2 v)
{
    float d_cell = 0.0;
    float d_sample = 0.0;
    if (length(v) < r_sample & length(v) <= r_cell)
    {
        float RENx_o = getIntersectX(v, r_cell_sq, false);
        if (v[0] >= 0 & abs(v[1]) < r_sample)
        {
            float RENx_i = getIntersectX(v, r_sample_sq, false);
            float REXx_i = getIntersectX(v, r_sample_sq, true);
            d_cell = abs(RENx_o - RENx_i) + abs(REXx_i - v[0]);
            d_sample = abs(RENx_i - REXx_i);
        }
        else
        {
            d_cell = abs(RENx_o - v[0]);
        }
    }
    return float2(d_cell, d_sample);
}

/* call ER_dists for coordinate per diffraction case, save in shader variable. */
[numthreads(16,16,1)]
void g1_dists (uint3 id : SV_DispatchThreadID)
{
    // 
    distancesOuter[id.x] = ER_dists_F2(segment[id.x]); 
    distancesInner[id.x] = ER_dists_F1(segment[id.x]);
}

/* call ER_dists for rotated coordinate per diffraction case, add to shader variable. */
[numthreads(64,1,1)]
void g2_dists (uint3 id : SV_DispatchThreadID)
{
    //float2 rv = mul(rot_mat, segment[id.x]);
    float2 rv = segment[id.x];
    distancesOuter[id.x] = distancesOuter[id.x] + ER_dists_F2(rv);
    distancesInner[id.x] = distancesInner[id.x] + ER_dists_F1(rv);
}