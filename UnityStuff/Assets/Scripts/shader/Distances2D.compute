// choose which functions get compiled.
//#pragma kernel OuterDistances
//#pragma kernel InnerDistances
#pragma kernel Distances
#pragma kernel Identity

// TODO: add as global/uniform variables.

   // int sideLength;
    float r_cell;   // outer radius
    float r_sample; // inner radius
    float m;     // 2*theta diffraction angle in 2D case.  
    float2 n;    // precomputed orthonormal vector of diffraction ray.  
   // int dummy3;     // TODO testaeaeaeaeae 

StructuredBuffer<float2> segment;
RWStructuredBuffer<float2> distances;   // x=dist_cell, y=dist_sample.


[numthreads(64,1,1)]
void Identity(uint3 id : SV_DispatchThreadID)
{
    distances[id.x] = segment[id.x];
}

/** Returns travel distance between intersection points of medium and ray, and segment point. */
float travelDist(uint3 id, float radius, float c, float ray_y0)
 {   
     // intersection of DR with medium exists <==> determinant of intersection x-coordinate is >= 0.
     if (pow(r_cell,2.0) - pow(dot(n,segment[id.x]),2.0) >= 0 && length(segment[id.x]) <= r_cell)
     {
         float d = sqrt(pow(radius,2) - pow(segment[id.x].x,2));                                                 // distance(vec, entrypoint).
         float2 exitpoint = dot(n, float2(c, sqrt(pow(radius,2) - c*c))) * float2(1,m) + float2(0,ray_y0);       // exit point of DR from cell.
         return d + distance(exitpoint, segment[id.x]);
     }
     return 0.0; // no intersections => no travel distance.
 }
 
 /**
 Computes travel distance of entering ray (ER) and diffracted ray (DR) through cell and sample. 
 */
[numthreads(64,1,1)]
void Distances(uint3 id : SV_DispatchThreadID)
{   
    float ray_y0 = segment[id.x].y - m*segment[id.x].x;                     // y-intercept of DR.
    float c = dot(n, segment[id.x]);                                        // c=ax+by=n^T*vec.

    /* Case 1: DR crosses sample. */ 
    distances[id.x].x = travelDist(id, r_cell, c, ray_y0);                  // ER/DR travel distance in cell+sample.
    distances[id.x].y = travelDist(id, r_sample, c, ray_y0);                // ER/DR travel distance in sample.
    
    /* Case 2: DR does not cross sample, but ER does. */
    if (length(segment[id.x]) <= r_cell && abs(segment[id.x].y) <= r_sample)
    {
        float h = abs(segment[id.x].y);
        distances[id.x].y = 2*sqrt(pow(r_sample,2)-pow(h,2));              // ER travel distance in sample.
    }
    distances[id.x].x = distances[id.x].x - distances[id.x].y;
}
