// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel get_indicator
#pragma kernel dists_part1
#pragma kernel dists_part2
#pragma kernel get_absorptions

#include "Shared.compute"

// PARAMETERS (constant):
float2 r;                                       // (cell,sample) radius of the medium.
float2 r2;                                      // r^2.
float2 mu;                                      // (cell,sample) mass attenuation coefficient.
float2 ray_dim;                                 // (width,height) dimensions of the ray.

// PARAMETERS (variable):
float2 rot;                                     // (cos,sin) of the rotation for a given theta.
float stretch;                                  // stretch factor to get 3D L2 dist. from 2D proj. L2. dist.

// BUFFERS (read-only):
StructuredBuffer<float2> segment;               // list of segment coordinates.

// BUFFERS (variable):
RWStructuredBuffer<float2> g1DistancesOuter;    // Diffraction only in cell.
RWStructuredBuffer<float2> g1DistancesInner;    // Diffraction only in sample.
RWStructuredBuffer<float2> g2DistancesOuter;    // Diffraction only in cell.
RWStructuredBuffer<float2> g2DistancesInner;    // Diffraction only in sample.
RWStructuredBuffer<uint2> indicatorMask;        // Pointwise indicatorCount if ray is diffracted in point.
RWStructuredBuffer<float3> absorptions;         // Absorption factors with diffraction/absorption in (s,sc), (c,sc), (c,c).


/* call ER_dists for coordinate per diffraction case, save in shader variable. */
[numthreads(1024,1,1)]
void dists_part1(uint3 id : SV_DispatchThreadID)
{
    g1DistancesOuter[id.x] = dists_case2(segment[id.x], r, r2); 
    g1DistancesInner[id.x] = dists_case1(segment[id.x], r, r2);
}


/* call ER_dists for rotated coordinate per diffraction case, add to shader variable. */
[numthreads(1024,1,1)]
void dists_part2(uint3 id : SV_DispatchThreadID)
{
    float2 rv = rotate_point(rot, segment[id.x]);
    g2DistancesOuter[id.x] = dists_case2(rv, r, r2);
    g2DistancesInner[id.x] = dists_case1(rv, r, r2);
}


/* call ER_dists for coordinate per diffraction case, save in shader variable. */
[numthreads(1024,1,1)]
void get_indicator(uint3 id : SV_DispatchThreadID)
{
    float norm = length(segment[id.x]);
    
    if (norm <= r.x && abs(segment[id.x].x) <= ray_dim.x)
    {
        if (norm > r.y)
            indicatorMask[id.x].y = 1;    // cases A_{c,sc}, A_{c,c}.
        else
            indicatorMask[id.x].x = 1;    // case A_{s,sc}.
    }
    else
        indicatorMask[id.x] = uint2(0, 0);
}


[numthreads(1024,1,1)]
void get_absorptions(uint3 id : SV_DispatchThreadID){
    if (indicatorMask[id.x].x > 0)
    {
        absorptions[id.x].x = exp(-dot(mu, g1DistancesInner[id.x] + g2DistancesInner[id.x] * stretch)); // case A_{s,sc}.
    }
    
    if (indicatorMask[id.x].y > 0) 
    {
        absorptions[id.x].y = exp(-dot(mu, g1DistancesOuter[id.x] + g2DistancesOuter[id.x] * stretch)); // case A_{c,sc}.
        absorptions[id.x].z = exp(-dot(float2(mu.x, 0.0), g1DistancesOuter[id.x] + g2DistancesOuter[id.x] * stretch)); // case A_{c,c}.
    }
}