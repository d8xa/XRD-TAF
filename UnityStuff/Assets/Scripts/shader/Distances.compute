// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

//TODO var for ProbeData
struct ProbeData {
    int sideLength;
    float r_cell;   //aussenradius glas
    float r_sample; //probenradius ohne glas
    float m_2D;     //2Theta + horizontale Pos des Voxel
    float m_3D;     //vertikale Pos des Voxel
    float m_n_2D;   //Steigung der Normalengerade
    int dummy2;
    int dummy3;     //TODO testaeaeaeaeae 
};
struct Segment {
    float2 pos;
};
struct Distances {
    float d_cell;
    float d_sample;
};

StructuredBuffer<Segment> segment;
RWStructuredBuffer<Distances> distance;

[numthreads(64,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if ((segment[id.x].pos[0]*segment[id.x].pos[0] + segment[id.x].pos[1]*segment[id.x].pos[1]) <= ProbeData.r_sample*ProbeData.r_sample) { 
        //float a = segment[id.x].pos[0]/sqrt(segment[id.x].pos[0]);
        //float b = m_n_2D/sqrt(1+m_n_2D*m_n_2D)
        float n_norm = 1/sqrt((segment[id.x].pos[0]+1)*(segment[id.x].pos[0]+1)+(segment[id.x].pos[0]+1)*m_n_2D*(segment[id.x].pos[0]+1)*m_n_2D);
        float2 n = float2((segment[id.x].pos[0] + 1)/n_norm, (segment[id.x].pos[0]+1)*m_n_2D/n_norm);
        float c = segment[id.x].pos[1] * n[0] + segment[id.x].pos[1] * n[1];
        float n_hyp = n[0]*n[0] + n[1]*n[1];
        float x_A = (n[0]*c + n[1]*sqrt(ProbeData.r_sample*ProbeData.r_sample*n_hyp-c*c))/n_hyp;
        float y_A = x_A * ProbeData.m_2D + (segment[id.x].pos[1] - ProbeData.m_2D * segment[id.x].pos);
        distance[id.x].d_cell = distance(float2(x_A,y_A), segment[id.x].pos);
        
        
    }
}
